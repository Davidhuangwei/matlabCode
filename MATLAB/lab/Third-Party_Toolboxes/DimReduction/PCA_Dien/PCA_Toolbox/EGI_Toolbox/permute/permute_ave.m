function [power,fsum,fchans]=permute_ave(cells,samplist,infile);%function [power,fsum,fchans]=permute_ave(cells,samplist,infile);%%Version 1.0%%Returns the sample by sample power value for an F statistic%summed across channels, as determined by the method of permutations.%The statistic is computed as the variance across means of cells%divided by the variance of means of subjects crossed with cells.%The power is determined by the percentile rank of the %statistic for the data compared to the sorted list of the statistic%computed for all permutations of cells withing subjects.%%The function also returns the F-sum statistic for each sample, and%the F value for each channel at each sample, in the second and %third output parameters, respectively.%%In theory the test can deal with any number of cells. However the%number of permutations for the test is the number of cells, factorial,%raised to the power of the number of subjects. Thus for two cells and%ten subject the number of permutations tested is 2^10 or 1024, per%sample in the parameter samplist. For 3 subjects the number is 6^10, or%60466176. Thus it may be impractical to use this routine for all%samples in such designs.% %For additional information see:%%Karniski, W., Blair, R.C., & Snider, A.D. (1994). An exact statistical%method for comparing topographic maps, with any number of subjects and%electrodes. Brain Topography, 6(3), 203-210.%%Version History:%%Begun 9/29/96 by Brian C. Rakitin%Check number of input argumentsif ~(nargin ==3)	error('Function requires 3 input arguments.');endif cells==[] | ~any(size(cells)==1) | samplist==[] | ~any(size(samplist)==1)	error('First and second arguments must be non-null row vectors.');end%Initialize EGIS header constantsave_hdr_offsets_v;infid=-1;[infid, errmsg]=fopen(infile, 'r');if infid==-1	disp(errmsg);	error(['Error opening file ' infile]);end[fhdr,chdr,ename,czeros,cgains,cnames,fcom,ftext, coff]=rd_egis_hdr_v(infid);if any(chdr(cells,NSamps)~=chdr(cells(1),NSamps))	fclose(infid);	error('Cells contain different number of samples.');endif any(chdr(cells,NObs)~=chdr(cells(1),NObs))	fclose(infid);	error('Cells contain different number of subjects.');endif length(samplist)>chdr(cells(1),NSamps)	fclose(infid);	error('Sample list has more elements than trials have samples.');endif any(samplist>chdr(cells(1),NSamps))	fclose(infid);	error('Sample list has one or more elements that are greater than last sample in trial.');endnumcells=length(cells);numobs=chdr(cells(1),NObs);numchans=fhdr(NChan);if samplist~=[]	numsamps=length(samplist);else	numsamps=chdr(cells(1),NSamps);endindata=zeros(numcells*numobs,numchans*chdr(cells(1),NSamps));for c=1:numcells	for n=1:numobs		trialdata=rd_onetr_allch(infid,coff(cells(c)),n,numchans,chdr(cells(1),NSamps));		indata((((c-1)*numobs)+n),:)=reshape(trialdata',1,numchans*chdr(cells(1),NSamps));	endendfclose(infid);temp_power=zeros(numsamps,1);temp_fsum=zeros(numsamps,1);temp_fchans=zeros(numsamps,numchans);permutations=permute([1:numcells]);permbase=prod([1:1:numcells]);numperms=permbase^numobs;curperm=zeros(numobs,1);for perm=0:numperms-1	permidx=zeros(numobs,numcells);	permdata=zeros(size(indata));	permidx=((permutations(curperm+1,:)-1).*numobs)+([1:numobs]'*ones(1,numcells));	permidx=reshape(permidx,numobs*numcells,1);	permdata=indata(permidx,:);	for samp=samplist		curstat=0;		for chan=1:numchans			msw=std(mean(reshape(permdata(:,((samp-1)*numchans)+chan),numobs,numcells))).^2;			msb=std(permdata(:,((samp-1)*numchans)+chan)).^2;			temp_fchans(samp,chan)=(msw./msb);			curstat=curstat+temp_fchans(samp,chan);		end %for chan=1:numchans		if perm==0			temp_fsum(samp)=curstat;					elseif curstat>temp_fsum(samp)			temp_power(samp)=temp_power(samp)+1;		end %if perm==0	end %samp=samplist	%Calculate next permutation	for n=1:numobs		if n==1			curperm(n)=curperm(n)+1;		elseif curperm(n-1)>=permbase			curperm(n)=curperm(n)+1;				end %if n==1	end %for n=1:numobs	curperm=rem(curperm,permbase);end %perm=0:numperms-1power=temp_power./numperms;fsum=temp_fsum;fchans=temp_fchans;