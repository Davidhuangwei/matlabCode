/*  FILETYPE.C  set the Macintosh file type and creator of a file  The calling syntax is:            [oldtype,oldcreator] = filetype(filename,type,creator)  Copyright (c)1995-97, Erik A. Johnson <johnsone@uiuc.edu>, 3/23/97    Thanks to Denis Pelli <denis@cns.nyu.edu> and David Brainard  <brainard@psych.ucsb.edu> for their helpful suggestions and testing.*/#ifndef MATLAB_MEX_FILE#define MATLAB_MEX_FILE 1#endif#include <stdio.h>#include <stdlib.h>#include <string.h>#include "mex.h"#ifdef MATLAB5#  define Matrix mxArray#  define mxIsString mxIsChar#  define mxFreeMatrix mxDestroyArray#  define CONST const#else#  define CONST#endif/* Input Arguments */#define    FN_IN    prhs[0]#define    FT_IN    prhs[1]#define    FC_IN    prhs[2]/* Output Arguments */#define FT_OUT   plhs[0]#define FC_OUT   plhs[1]#define    max(A, B)    ((A) > (B) ? (A) : (B))#define    min(A, B)    ((A) < (B) ? (A) : (B))static OSErr _TickleParent(FSSpec *child)    /* cause Finder to update the icons */  {CInfoPBRec    pb;   OSErr         err = noErr;    pb.dirInfo.ioCompletion = 0;    pb.dirInfo.ioNamePtr = 0;    pb.dirInfo.ioVRefNum = child->vRefNum;    pb.dirInfo.ioFDirIndex = -1;              /* get info based on the DirID */    pb.dirInfo.ioDrDirID = child->parID;    if ((err=PBGetCatInfoSync(&pb)) != noErr) return err;    GetDateTime( &pb.dirInfo.ioDrMdDat );    err = PBSetCatInfoSync( &pb );    return( err);   }static void _MexErrMsgTxt(char *str1, char *str2, char *str3, OSErr err)  {char str[2048];    strcpy(str,str1);    strcat(str,str2);    strcat(str,str3);    if (err!=noErr) {strcat(str," (Error #");/*numtostring(err,str+strlen(str));*/sprintf(str+strlen(str),"%d",err);/**/strcat(str,")");}    mexErrMsgTxt(str);   }static void _FilenameToPathname(char *fn, StringPtr _fname)  {char *s;   Matrix *lhs[1]={(Matrix*)nil},*rhs[1]={(Matrix*)nil};   short _len=0, fnlen;    if ((fn==(char*)nil) || (_fname==(StringPtr)nil)) return;    for (s=fn; (*s!='\0')&&(*s!=':'); s++) ;    fnlen = strlen(fn);    if ((*fn==':') || (*s=='\0')) /*partial pathname if no ':' or if 1st char==':'*/      { /* call "cd" to get the current directory */        mexCallMATLAB(1,lhs,0,rhs,"cd");        if ((!mxIsString(lhs[0])) || mxIsNumeric(lhs[0]))            mexErrMsgTxt("FILETYPE requires that CD return a string.");        _len = fnlen + mxGetM(lhs[0])*mxGetN(lhs[0]) + ((*fn!=':')?1:0);        if (_len > 254)            mexErrMsgTxt("FILETYPE found that the full pathname was too long (>255 characters).");        mxGetString( lhs[0], (char*)_fname+1, 254 );        _len = strlen((char*)_fname+1);        if ((*fn!=':')&&((_len<=0)||(_fname[_len]!=':'))) _fname[++_len]=':';        if ((_fname[_len]==':') && (*fn==':')) _len--;        mxFreeMatrix(lhs[0]);       }    else if (fnlen>254)        mexErrMsgTxt("FILETYPE found that the full pathname was too long (>255 characters).");    BlockMove( fn, _fname+_len+1, fnlen );    _fname[(_fname[0]=_len+fnlen)+1]='\0';   }static void _PathnameToVolumeName(StringPtr _fname, StringPtr _volname)  {char *s,*d;    for (s=(char*)_fname+1,d=(char*)_volname+1; (*s!='\0')&(*s!=':'); )    	*d++ = *s++;    *d = *s;    if (*s==':') *++d='\0';    _volname[0] = (d-(char*)_volname)-1;   }static void filetype(char *fn, OSType *oldtype, OSType *oldcrea,                               OSType    ftype, OSType    fcrea,                               int  changetype, int  changecrea)  {FSSpec _myFile;   Str255 _fname,_volname;   FInfo  _fInfo;   OSErr  _err;    _FilenameToPathname(fn,_fname);    _PathnameToVolumeName(_fname,_volname);    _err = FSMakeFSSpec(0, /*LMGetCurDirStore()*/0, _fname, &_myFile);    if (_err == noErr)      { _err=FSpGetFInfo(&_myFile,&_fInfo);        if (_err==fnfErr) _MexErrMsgTxt("FILETYPE: directories (e.g., '",fn,"') have no file type/creator.",noErr);       }    if (_err == noErr)      { if (oldtype)    *oldtype = _fInfo.fdType;        if (oldcrea)    *oldcrea = _fInfo.fdCreator;        if (changetype||changecrea)          { if (changetype) _fInfo.fdType   =ftype;            if (changecrea) _fInfo.fdCreator=fcrea;            _err=FSpSetFInfo(&_myFile,&_fInfo);            if (_err == noErr) _err=_TickleParent(&_myFile);           }       }    if (_err == fnfErr)         _MexErrMsgTxt("FILETYPE could not find the file '",fn,"'.",noErr);    else if (_err == bdNamErr)  _MexErrMsgTxt("FILETYPE got a bad file name '",fn,"'.",noErr);    else if (_err == ioErr)     _MexErrMsgTxt("FILETYPE got an I/O error on file '",fn,"'.",noErr);    else if (_err == nsvErr)    _MexErrMsgTxt("FILETYPE could not find the volume '",(char*)_volname+1,"'.",noErr);    else if (_err == paramErr)   mexErrMsgTxt("FILETYPE could not find a default volume.");    else if (_err == fLckdErr)  _MexErrMsgTxt("FILETYPE found that the file '",fn,"' is locked.",noErr);    else if (_err == vLckdErr)  _MexErrMsgTxt("FILETYPE found that the volume '",(char*)_volname+1,"' is locked.",noErr);    else if (_err == wPrErr)    _MexErrMsgTxt("FILETYPE found that the volume '",(char*)_volname+1,"' is locked (hardware).",noErr);    else if (_err == dirNFErr)  _MexErrMsgTxt("FILETYPE could not find a directory in path '",(char*)_fname+1,"'.",noErr);    else if (_err != noErr)     _MexErrMsgTxt("FILETYPE got an unknown error with file '",fn,"'.",_err);   }/* check if we are running under MATLAB 5 */static int isMatlab5()  {static int firsttime=1,ans;   Matrix *lhs[1]={(Matrix*)nil};   char *buf;   int n;    if (firsttime)      { mexCallMATLAB(1,lhs,0,lhs,"version");        n = mxGetM(lhs[0])*mxGetN(lhs[0]);        buf = mxCalloc(2*n+1,sizeof(char));        mxGetString(lhs[0],buf,2*n+1);        ans = *buf >= '5';        mxFree(buf);        mxFreeMatrix(lhs[0]);        firsttime = 0;       }    return(ans);   }/* get a row from a string matrix, handling MATLAB 4 and 5 versions, and multi-byte characters */static char *get_string_row(const Matrix *mat, int rownum, int deblank)  {unsigned short *src5,c;   double *src4;   unsigned char *dst,*dstend;   char *ans;   int numrows,numcols;    /* find out how big it is and allocate space */    numrows=mxGetM(mat); numcols=mxGetN(mat);    ans = (char*) mxCalloc(2*numcols+1,sizeof(unsigned char));    dst = dstend = (unsigned char*) ans;    if (rownum>=numrows) {*ans='\0'; return(ans);}    /* get the row */    for (src5=((unsigned short*)mxGetPr(mat))+rownum,src4=((double*)mxGetPr(mat))+rownum; --numcols>=0; src5+=numrows,src4+=numrows)      { c = isMatlab5() ? *src5 : ((unsigned short)((*src4)+0.5));        if (c>256) *dst++=c>>8;        *dst++=c&0x0ff;        if (c!='\0' && c!=' ') dstend=dst;       }    *(deblank?dstend:dst) = '\0';    return((char*)ans);   }/* set a row of an N-by-4 string matrix, handling MATLAB 4 and 5 versions */static void set_row_ostype(Matrix *mat, int rownum, OSType type)  {unsigned short *dst5,c;   double *dst4;   unsigned char *s;   int i,numrows;    s = (unsigned char *)(&type);    numrows=mxGetM(mat);    for (dst5=((unsigned short*)mxGetPr(mat))+rownum,dst4=((double*)mxGetPr(mat))+rownum,i=4; --i>=0; dst5+=numrows,dst4+=numrows)      { c = isMatlab5() ? *dst5 : ((unsigned short)((*dst4)+0.5));        if (isMatlab5()) *dst5=*s++;        else             *dst4=*s++;       }   }/* get a row of an N-by-4 string matrix, handling MATLAB 4 and 5 versions, ignoring multi-byte characters */static OSType get_row_ostype(Matrix *mat, int rownum)  {unsigned short *src5,c;   double *src4;   OSType ans;   unsigned char *p;   int numrows,i;    /* find out how big it is */    numrows = mxGetM(mat);    /* get the row */    for (p=(unsigned char*)(&ans),src5=((unsigned short*)mxGetPr(mat))+rownum,         src4=((double*)mxGetPr(mat))+rownum,i=4; --i>=0; src5+=numrows,src4+=numrows)      { c = isMatlab5() ? *src5 : ((unsigned short)((*src4)+0.5));        *p++ = c&0x0ff;       }    return( ans );   }void mexFunction(int nlhs, Matrix *plhs[], int nrhs, CONST Matrix *prhs[])  {unsigned int fnm=0,fnn,ftm=0,ftn,fcm=0,fcn;   char *fn,*buf,*p;   OSType ftype,fcrea,oldtype,oldcrea;   int k;    /* Check for proper number of arguments */    if (nrhs > 3)  mexErrMsgTxt("FILETYPE takes at most three input arguments.");    else if (nlhs > 2)  mexErrMsgTxt("FILETYPE produces at most two output arguments.");    /* Check FN */    if (nrhs >= 1)      { fnm = mxGetM(FN_IN);        fnn = mxGetN(FN_IN);        if (fnn==0) fnm=0;        if (!mxIsString(FN_IN)) mexErrMsgTxt("FILETYPE requires that the filename be a string.");       }    /* Check FT */    if (nrhs >= 2)      { ftm = mxGetM(FT_IN);        ftn = mxGetN(FT_IN);        if (ftn==0) ftm=0;        if (!mxIsString(FT_IN) || (ftm>0 && (ftn!=4 || ftm!=fnm&&ftm>1)))            mexErrMsgTxt("FILETYPE requires that the file TYPE be an Nx4 string.");       }        /* Check FC */    if (nrhs >= 3)      { fcm = mxGetM(FC_IN);        fcn = mxGetN(FC_IN);        if (fcn==0) fcm=0;        if (!mxIsString(FC_IN) || (fcm>0 && (fcn!=4 || fcm!=fnm&&fcm>1)))            mexErrMsgTxt("FILETYPE requires that the file CREATOR be an Nx4 string.");       }        /* create matrices for the return arguments */    buf = mxCalloc(4*fnm+1,sizeof(char));    for (p=buf,k=4*fnm; --k>=0; ) *p++=' '; *p='\0';    FT_OUT=mxCreateString(buf); mxSetM(FT_OUT,fnm); mxSetN(FT_OUT,4);    if (nlhs>1) {FC_OUT=mxCreateString(buf); mxSetM(FC_OUT,fnm); mxSetN(FC_OUT,4);}    mxFree(buf);         /* loop over the filenames */    for (k=0; k<fnm; k++)      { fn = get_string_row(FN_IN,k,fnm>1);        if (ftm>0 && (k==0||ftm>1)) ftype=get_row_ostype(FT_IN,k);        if (fcm>0 && (k==0||fcm>1)) fcrea=get_row_ostype(FC_IN,k);        filetype(fn,&oldtype,&oldcrea,ftype,fcrea,ftm>0,fcm>0);        set_row_ostype(FT_OUT,k,oldtype);        if (nlhs>1) set_row_ostype(FC_OUT,k,oldcrea);        mxFree(fn);       }    return;   }